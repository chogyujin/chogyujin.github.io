---
layout: post
title:  "2.10 메모리 보안"
date:   2019-03-26 21:18:54
categories: OS
comments: true
---

-> [목차](https://chogyujin.github.io/2019/03/17/%EB%AA%A9%EC%B0%A8/)  

예를 들어 하나의 사용자 프로그램이 C언어의 포인터 등 메모리 주소 참조 연산을 잘못 사용해 다른 사용자 프로그램의  

메모리 영역이나 운영 체제 커널이 위치한 영역을 침범할 수 있기때문에 적어도 인터럽트 벡터와 인터럽트 처리 루틴이  

있는 곳은 각별한 보안이 필요하다.  

이러한 문제를 해결하기 위해 두 개의 레지스터를 사용한다.  

**기준 레지스터**는 어떤 프로그램이 수행되는 동안 그 프로그램이 합법적으로 접근할 수 있는 메모리 상의 *가장 작은 주소*를  

보관할 수 있고, **한계 레지스터**는 그 프로그램이 기준 레지스터 값부터 접근할 수 있는 *메모리 범위*를 보관하고 있다.  

사용자 프로그램은 기준 레지스터에 있는 주소부터 기준 레지스터 + 한계 레지스터 값 사이의 주소 영역만 접근이 가능하며  

접근하려는 주소가 이 범위 안에 없으면 `예외 상황`이라는 일종의 소프트웨어적인 인터럽트가 발생하게 된다.  

예외 상황은 운영 체제에게 소프트웨어적인 인터럽트를 발생시켜 CPU의 제어권을 해당 프로그램으로부터 운영 체제로 이양시키고  

운영 체제는 예외 상황을 발생시킨 프로그램을 강제 종료시킨다.  

> 여기에서 살펴본 메모리 보호 기법은 하나의 프로그램이 메모리의한 영역에 연속적으로 위치한 경우에 대한 설명이다.  
후반부에선 하나의 프로그램이 메모리의 여러 영역에 나뉘어 위치하는 페이징(paging)기법 등에 대해서도 다룰 것이다.  

메모리 접근 연산은 사용자 프로그램이 CPU를 가지고 있는 동안에도 수행할 수 있는 연산이므로 특권 명령은 아니다.  

다만, 사용자 프로그램이 메모리를 접근하기 전에 하드웨어적으로 그 접근이 합법적인지를 체크하여 메모리를 보호하게 된다.  

이것이 운영체제만이 수행할 수 있는 입출력 연산과 메모리 접근 연산과의 차이점이다.  

그러므로 운영 체제가 두 개의 레지스터 값을 직접 세팅해 주고 사용자 프로그램은 값을 변경할 수 없게 한다.  

---  

---  

  

위 글은 `운영 체제와 정보 기술의 원리 -반효경`책을 정리하기 위해 쓴 글입니다.  
https://book.naver.com/bookdb/book_detail.nhn?bid=4392911
