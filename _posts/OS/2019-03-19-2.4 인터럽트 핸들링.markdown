---
layout: post
title:  "2.4 인터럽트 핸들링"
date:   2019-03-19 22:33:54
categories: OS
comments: true
---

-> [목차](https://chogyujin.github.io/2019/03/17/%EB%AA%A9%EC%B0%A8/)  

`인터럽트 핸들링(interrupt handling)`이란 인터럽트가 발생한 경우에 처리해야 할 일의 절차를 의미한다.  

CPU에서 명령이 수행될 때에는 CPU 내부에 있는 임시 기억 장치인 `레지스터(register)`에  

데이터를 읽어오거나 쓰면서 작업을 수행하게 되는데, 이 때 인터럽트가 발생해 새로운 명령을 수행하면  

기존의 레지스터 값들이 지워지게 되므로 레지스터 값 등 CPU 내의 하드웨어 상태를 저장해 두어야 한다.  

이것을 모두 저장한 후에야 인터럽트 처리가 이루어 질 수 있다.  

---

운영 체제 커널 영역에는 현재 시스템 내에서 수행되는 프로그램들을 관리하기 위한 자료 구조인  

`프로세스 제어 블록(PCB: Process Control Block)`을 두고 있다.  

그 자료 구조 중 일부분은 인터럽트가 발생했을 때 프로그램의 어느 부분이 수행되던 중이었는지를 저장하기 위한 자료구조로 사용된다.  

이 부분에 저장되는 내용으로는 현재 수행중이던 `메모리 주소`와 `레지스터 값`, 그리고 `하드웨어 상태` 등이 있다.  

이러한 정보가 저장되었다가 인터럽트 수행이 끝나면 저장된 값을 CPU 상에 다시 복원해 인터럽트당하기 직전의 명령을  

계속 수행할 수 있게 되는 것이다.  

---

비록 커널이 하나의 프로그램이지만 여러 사용자 프로그램이 수행되는 도중에 인터럽트 등을 통해 커널코드가 수행될 수 있으므로  

커널은 일종의 `공유 코드`라고 볼 수 있다.  

즉, 인터럽트 처리 루틴으로 넘어와서 함수 호출이 이루어질 경우에는 각 프로세스 별로 독자적인 커널 스택을 사용하게 된다.  

다시 말하면 직전에 인터럽트당한 프로세스의 독자적인 커널 스택에 함수 호출 및 리턴과 관련된 정보를 저장하게 되는 것이다.  

---

원칙적으로는 인터럽트 처리중에 또 다른 인터럽트가 발생하는 것을 허용하지 않는다.  

그 이유는 인터럽트 처리중에 다른 인터럽트를 처리하게 되면 데이터의 일관성이 유지되지 않는 경우가 발생할 수 있기 때문이다.  

하지만 예외가 존재한다.  

인터럽트마다 중요도가 다르기 때문에 중요도가 더 높은 인터럽트가 발생하는 것을 허락할 필요가 있다.  

---

다음으로 `소프트웨어 인터럽트`에 대해 설명하겠다.  

통상적으로 인터럽트라고 하면 하드웨어 인터럽트를 의미하고, 소프트웨어 인터럽트는 `트랩(trap)`이라는 용어를 사용한다.  

소프트웨어 인터럽트의 예로는 `예외 상황(exception)`, `시스템 콜(system call)`등이 있다.  

**예외 상황**이란 프로세스가 0으로 나누는 연산 등 불가능한 작업을 시도하거나, 메모리 영역 바깥을 접근하려할 때,  

이에 대한 처리를 위해 발생시키는 인터럽트를 말한다.  

**시스템 콜**이란 프로그램이 자신이 작성하지 않은 코드를 운영 체제로부터 서비스받기 위해 발생시키는 인터럽트를 말한다.  

예를들어 printf()의 내용을 이미 라이브러리 함수로 작성해 두었고, 이 라이브러리 함수가 궁극적으로는 운영 체제 내에  

정의된 write()라는 시스템 콜을 호출한다.  





---  

---  

  

위 글은 `운영 체제와 정보 기술의 원리 -반효경`책을 정리하기 위해 쓴 글입니다.  
https://book.naver.com/bookdb/book_detail.nhn?bid=4392911
