---
layout: post
title:  "1.5 운영 체제의 자원 관리 기능"
date:   2019-03-18 18:28:54
categories: OS
comments: true
---

-> [목차](https://chogyujin.github.io/2019/03/17/%EB%AA%A9%EC%B0%A8/)

# 1.5 운영 체제의 자원 관리 기능

운영 체제의 가장 핵심적인 기능은 자원을 효율적으로 관리하는 것이다.  

자원은 하드웨어 자원과 소프트웨어 자원으로 나뉘는데, 이 장에선 하드웨어 자원만 다루도록 하겠다.  

하드웨어 자원은 크게 `CPU`, `메모리(memory)`, `주변 장치`가 있다.  

### 1.5.1 CPU를 관리하는 방법

매 시점 어떠한 프로세스에게 CPU를 할당해 작업을 처리할 것인지 결정하는 일이 필요한데 이를 `CPU 스케줄링(CPU scheduling)`이라고 한다.  

CPU 스케줄링의 목표는 CPU를 가장 효율적으로 사용하면서도, 특정 프로세스가 불이익을 당하지 않도록 하는 것이다.  

대표적인 CPU 스케줄링 기법으로 `선입선출(FCFS:First Come First Served)`, `라운드 로빈(Round Robin)`, `우선순위(priority)`기법이 있다.  

- **선입선출(FCFS)**  

> 먼저 CPU를 사용하기 위해 도착한 프로세스를 먼저 처리해 주는 방식.  
이는 우리가 일상 생활에서 줄서기를 하는 것과 유사하다. 이 방식에서는 CPU를 필요로 하는 프로세스가 여럿 있을 때,  
먼저 CPU를 요청한 프로세스가 원하는 작업을 완료할 때까지 다른 프로세스들이 CPU를 사용하지 못하게 된다.  
전체 시스템 입장에선 비효율적인 결과를 초래할 가능성이 있다.  
이러한 선입선출 기법의 단점을 보완하고자 고안된 기법이 `라운드 로빈`기법이다.  

- **라운드 로빈**

> CPU를 한 번 할당받아 사용할 수 있는 시간을 일정한고정된 시간으로 제한한다.  
그래서 긴 작업을 요하는 프로세스가 CPU를 할당받더라도 정해진 시간이 지나면 CPU를 내어놓고,  
CPU의 서비스를 기다리는 줄의 제일 뒤에 가서 기다려야 한다.  
그러므로 짧은 작업을 가진 프로세스들이 긴 작업을 수행하는 프로세스 때문에 무작정 오래 기다려야하는 상황을 막을 수 있다.  
보통 1회 할당 시간은 수 밀리 세컨트(ms)정도의 단위를 사용한다.  

- **우선순위**

> 수행 대기중인 프로세스들에게 우선순위를 부여하고 우선순위가 높은 프로세스에게 CPU를 먼저 할당하게 된다.  
또한, 지나치게 오래 기다리는 프로세스가 발생하지 않도록, 기다린 시간이 늘어날수록 우선순위를 점차 높여 준다.  

### 1.5.2 메모리를 관리하는 방법

프로그램이 CPU에서 수행되려면 해당 부분이 메모리에 올라가 있어야 한다.  

메모리 관리를 위해 운영 체제는 메모리의 어느 부분이 어떤 프로그램에 의해 사용되고 있는지를 유지하게 되는데  

이러한 정보는 주소(address)를 통해 관리된다.  

운영 체제는 프로그램에게 메모리가 필요할 때 할당하고, 더 이상 필요하지 않게 될 때 회수한다.  

또한, 다수의 사용자 프로그램이 동시에 메모리에 올라간 경우 서로 다른 프로세스의 영역을 침범하지 않도록 보안을 유지하는 역할도 한다.  

물리적 메모리를 관리하는 방식에는 `고정 분할(fixed partition)`방식, `가변 분할(variable partition)`방식, `가상 메모리(virtual memory)` 방식이 있다.  

- **고정 분할**  

> 물리적 메모리를 몇 개의 영구적인 분할로 나눈다.  
동시에 메모리에 적재되는 최대 프로그램의 수가 분할 개수로 한정되기 때문에 융통성이 없는 단점이 있다.  
또한, 분할의 크기보다 큰 프로그램은 적재가 불가능하기 때문에 효율성도 떨어진다.  
분할이 고정적이기 때문에 분할의 크기보다 작은 프로그램이 적재되는 경우, 남는 영역이 발생하게 된다.  
이를 `내부 조각(internal fragmentation)`이라 한다.

- **가변 분할 방식**

> 매 시점 프로그램의 크기에 맞게 메모리르 분할해서 사용하는 방식을 말한다.  
고정 분할 방식에서 발생하는 내부 조각은 발생하지 않지만 `외부 조각(external fragmentaion)`이 발생할 수 있다.  
  > > - 외부 조각이 발생하는 예  
크기가 100인 프로그램 A가 실행되어 메모리에 100만큼의 영역을 할당 받았다.  
프로그램 A가 실행되는 도중에 크기가 50인 프로그램 B가 실행되어 A의 영역 바로 다음부터 메모리 공간 50을 할당받아 실행 되고 있다.  
이 때 A의 작업이 완료되어 A의 영역에 크기 80인 프로그램 C가 적재되면 20의 빈 공간이 생기게 된다.  
이 때, 크기가 40인 프로그램 D가 실행된다면 공간이 충분하지 못해 사용되지 못한다.  

- **가상 메모리 기법**

최근의 거의 모든 컴퓨터 시스템에서 사용하는 메모리 관리 기법이다.  

가상 메모리 기법을 사용하면 물리적 메모리보다 더 큰 프로그램을 실행시킬 수 있다.  

모든 프로그램은 물리적 메모리와는 독립적으로 주소가 0부터 시작하는 자신만의 가상 메모리를 갖게 된다.  

운영 체제는 가상 메모리의 주소를 물리적 메모리 주소로 매핑하는 기술을 이용해 주소를 변환시킨 후 프로그램을 물리적 메모리에 올린다.  

현재 사용되고 있는 부분만 메모리에 올리고, 나머지는 하드 디스크와 같은 보조 기억장치에 저장해 두었다가 필요할 때 적재하는 방식을 취한다.  

이 때 사용되는 보조 기억 장치의 영역을 `스왑 영역(swap area)`이라 한다.  

프로그램을 구성하는 주소 공간은 페이지라는 동일한 크기의 작은 단위로 나뉘어 물리적 메모리와 스왑 영역에 일부분씩 저장된다.  

이렇게 동일한 단위로 메모리를 나누는 기법을 `페이징(paging)`기법이라 한다.  

### 1.5.3 주변 장치 및 입출력  

주변 장치 들은 CPU의 서비스가 필요한 경우에 신호를 발생시켜 서비스를 요청하게 되는데,  

이 때 발생시키는 신호를 `인터럽트(interupt)`라고 한다.  

CPU는 평소에 CPU 스케줄링에 따라 주어진 작업을 수행하고 있다가 인터럽트가 발생하면 하던 일을 잠시 멈추고,  

인터럽트에 의한 요청 서비스를 수행하게 된다.  

인터럽트를 처리한 운영 체제는 다시 원래 수행하던 작업으로 돌아오기 위해 인터럽트 처리 직전에 수행중이던 작업의 상태를 저장해 둔다.  

인터럽트는 요청하는 장치와 발생 상황에 따라 다양한 종류가 있기 때문에 운영 체제는 인터럽트 종류마다 서로 다른 인터럽트 처리 루틴을 갖고 있다.  

한편, 주변 장치들은 각 장치마다 그 장치에서 일어나는 업무에 대한 관리를 위한 일종의 작은 CPU를 가지고 있다.  

이를 우리는 `컨트롤러(controller)`라고 부른다. 컨트롤러는 해당 장치에 대한 업무를 처리하고  

이를 메인 CPU에 인터럽트를 발생시켜 보고하는 역할을 한다.  


---  
  

위 글은 `운영 체제와 정보 기술의 원리 -반효경`책을 정리하기 위해 쓴 글입니다.  
https://book.naver.com/bookdb/book_detail.nhn?bid=4392911
