---
layout: post
title:  "[swea] 6109. 추억의 2048게임"
date:   2019-03-01 12:01:54
categories: Algorithm
comments: true
---

https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWbrg9uabZsDFAWQ  

생각할게 많은 문제였습니다.  

저 같은 경우 예를들어 위로 민다 치면,  

(0,0)부터 (0,n-1)까지 main에서 반복문을 돌리고  

비교함수안에서는 아래방향을 봐서 서로 비교하고 연산하도록 했습니다.  

생각해야할 상황이 많았기 때문에 많은 생각이 필요했습니다.  

설명은 코드에서 주석으로 넣었습니다.  

~~~
#include<iostream>
using namespace std;
int n;
int map[21][21];
int dx[] = { 0,-1,0,1 };//좌,상,우,하
int dy[] = { -1,0,1,0 };
void move(int x, int y, int dir) {//좌,상,우,하방향으로 본다
    int curx = x, cury = y;//현재지점 저장
    int nx = x;
    int ny = y;
    for (int i = 0; i < n - 1; i++) {
        nx += dx[dir];
        ny += dy[dir];
        if (map[curx][cury] != 0) {//현재지점 값이 0이 아닐 때
            if (map[nx][ny] != 0) {//비교할 값이 0이 아닐 때
                if (map[curx][cury] == map[nx][ny]) {//현재값과 비교값이 같으면
                    map[curx][cury] *= 2;//2배
                    map[nx][ny] = 0;//비교값 0
                    curx += dx[dir];//연산1번밖에 못하므로 현재지점 변경
                    cury += dy[dir];
                }
                else {//비교할 값이 현재값과 다를 때
                    curx += dx[dir];//현재지점 변경
                    cury += dy[dir];
                    if (nx != curx || ny != cury) {//현재지점과 비교지점이 다른 지점이면
                        map[curx][cury] = map[nx][ny];//현재지점에 비교값을 옮긴다
                        map[nx][ny] = 0;
                    }
                }
            }
        }
        else {//현재지점 값이 0일 때
            if (map[nx][ny] != 0) {//비교할 값이 0이 아닐 때
                map[curx][cury] = map[nx][ny];//현재지점의 값이 0이었으므로 변경지점의 값을 넣는다
                if (nx != curx || ny != cury) {//현재지점과 비교지점이 다르면 비교지점을 0으로 바꾼다
                    map[nx][ny] = 0;
                }
            }
        }
    }

}
int main(int argc, char** argv)
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    int test_case;
    int T;
    cin >> T;
    for (test_case = 1; test_case <= T; ++test_case)
    {//start
        n = 0;
        map[21][21] = { 0, };
        char s[20];
        cin >> n >> s;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) cin >> map[i][j];
        }
        if (s[0] == 'l') {//left
            for (int i = 0; i < n; i++) move(i, 0, 2);
        }
        else if (s[0] == 'r') {//right
            for (int i = 0; i < n; i++) move(i, n - 1, 0);
        }
        else if (s[0] == 'u') {//up
            for (int i = 0; i < n; i++) move(0, i, 3);
        }
        else if (s[0] == 'd') {//down
            for (int i = 0; i < n; i++) move(n - 1, i, 1);
        }
        //출력
        cout << '#' << test_case << '\n';
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                cout << map[i][j] << ' ';
            }cout << '\n';
        }
    }
    return 0;
}
~~~




- **혼잣말**

char str[20];  
cin >> str; 일때  
if(str=="up") 이렇게 비교하면  
"up"자리를 모르므로 strcmp를 쓰자!  
아니면  
if(str[0]=='u')을 하자  
아니면 string으로 입력 받자  
