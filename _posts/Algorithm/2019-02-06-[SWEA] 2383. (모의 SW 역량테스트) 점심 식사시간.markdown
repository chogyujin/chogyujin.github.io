---
layout: post
title:  "[SWEA] 2383 (모의 SW 역량테스트) 점심 식사시간"
date:   2019-02-06 19:14:54
categories: Algorithm
comments: true
---

https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5-BEE6AK0DFAVl#;return%20false;  


- 풀이
dfs를 활용하여 어떤 계단을 이용할지 완탐하였습니다.  

1. 입력 받을 때, 사람의 위치와 사람수를 저장, 계단의 위치와 소요시간을 저장한다.  

2. dfs를 통해 각 사람마다 가고자하는 계단을 체크해논다 (코드에선 ch배열 사용)  

3. ch배열에서 true로 체크된 사람들과 false로 체크된 사람들을 나눈 후 계단에 각각 넣는다.  

4. 배열을 통해 사람들마다 계단까지 걸리는 시간을 저장해논다(코드에선 ptime배열)  

5. while문을 통해 한번 반복할때마다 시간이 +1되게 해준다.  

6. 각 시간마다 for문을통해 모든 사람들의 시간이 -1되게 해준다.  

7. 시간이 0분이 되면 계단을 내려가게한다.  

8. ★★★ 계단 인원이 3인데, 대기자가 있을 경우 기존 시간에 -1을 해주어 시작한다  
   사람이 빠져나가면 바로 내려가야하는데 본 코드에선 1분 후에 내려가므로 -1해주고 시작.  

9. 이제 큐를 이용해서 계단 내부를 코딩한다. 큐에 있는 data를 하나씩 빼서 -1해주고(코드에선temp변수)  
    만약 시간이 -1이 되었다면 사람이 빠져나간 것이므로 빠져나간 사람수를 +1해준다(코드에선exit변수)  
    (계단 내부 반복문에선 값을 받자마자 -1해주므로 0이아닌 -1일때 사람이 나간다고 체크했습니다.)  

10. 이렇게 반복하다가 사람수와 빠져나간 사람 수가 같을 경우 종료한다.  


~~~
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
int result, pcnt;
int map[11][11];
bool ch[11];//사람마다 가야할 계단 체크
bool quick[11];//계단에 대기 타고 있는사람
int ptime[2][11];//사람마다 걸리는시간(people time)
queue <int> q[2];
struct position {
	int r, c, stair;
};
position p[11];
position s[2];//false계단,true계단
int abs(int x) {
    return x < 0 ? -x : x;
}
void go() {
    for (int i = 0; i < pcnt; i++) {//fasle계단은 0번, true계단은 1번
        int temp;
        if (ch[i] == 0) {
            temp = abs(p[i].r - s[0].r) + abs(p[i].c - s[0].c);
            ptime[0][i] = temp + 1;//각각 소요시간 저장
        }
        else {
            temp = abs(p[i].r - s[1].r) + abs(p[i].c - s[1].c);
            ptime[1][i] = temp + 1;
        }
    }
    int time = 0;
    int exit = 0;
    while (1) {//1분 흐를때마다 체크
        time++;//시간
        for (int i = 0; i < pcnt; i++) {
            if (ptime[0][i] >= 0) {//0번계단
                ptime[0][i]--;//위에 있는 사람들 소요시간을 -1씩
                if (ptime[0][i] == 0) {//0이라는건 계단에 도착했다는 뜻이므로
                    if (q[0].size() < 3) {//큐,즉 계단 안사람들이 3미만인 경우만
                        if (quick[i] == true) {//★★★quick배열을 통해 대기했던 사람은 -1해서 시작
                            q[0].push(s[0].stair - 1);
                        }
                        else q[0].push(s[0].stair);//대기 안했던 사람은 그냥 들어감
                    }
                    else {//★★★계단에 공간생기자마자 바로들어가야되는데 1분뒤에들어가므로
                        ptime[0][i]++;//이건 그냥 위에서 다시0으로만들어줘야하므로
                        quick[i] = true;//여기서 대기인사람을 true로 표시해논다
                    }
                }
            }
            else if (ptime[1][i] >= 0) {//1
                ptime[1][i]--;
                if (ptime[1][i] == 0) {
                    if (q[1].size() < 3) {
                        if (quick[i] == true) {
                            q[1].push(s[1].stair - 1);
                        }
                        else q[1].push(s[1].stair);
                    }
                    else {
                        ptime[1][i]++;
                        quick[i] = true;
                    }
                }
            }
        }

        //계단내부
        int _size0 = q[0].size();
        for (int j = 0; j < _size0; j++) {//큐 사이즈만큼 반복
            int temp = q[0].front();
            q[0].pop();
            temp--;//큐에서 나온애를 -1해준다.(시간)
            if (temp == -1) {//temp가 0미만으로 줄었으면 나갔다는 것이므로
                exit++;//exit는 나간 인원
                continue;
            }
            else q[0].push(temp);//아직 계단에 있는 경우
        }
        int _size1 = q[1].size();//1
        for (int j = 0; j < _size1; j++) {
            int temp = q[1].front();
            q[1].pop();
            temp--;
            if (temp == -1) {
                exit++;
                continue;
            }
            else q[1].push(temp);
        }		
        if (exit == pcnt) {//나간인원과 처음 사람 숫자가 같을 시
            result = result > time ? time : result;//갱신
            break;
        }	
    }
}
void dfs(int idx, int cnt) {//dfs를 통한 완탐
    memset(ptime, -1, sizeof(ptime));
    memset(quick, false, sizeof(quick));
    go();
    for (int i = idx; i < pcnt; i++) {
        if (ch[i] == false) {//true계단과 false계단으로 나눔
            ch[i] = true;
            dfs(i, cnt + 1);
            ch[i] = false;
        }
    }
}
int main() {
    int t;
    scanf("%d", &t);
    for (int test_case = 1; test_case <= t; test_case++) {
        int n;
        result = 2e9;
        pcnt = 0;
        int scnt = 0;
        memset(p, 0, sizeof(p));
        memset(s, 0, sizeof(s));
        scanf("%d", &n);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                scanf("%d", &map[i][j]);
                if (map[i][j] == 1) {//사람 위치 저장
                    p[pcnt].r = i;
                    p[pcnt].c = j;
                    pcnt++;//사람숫자
                }
                else if (map[i][j] >= 2) {//계단 위치 저장
                    s[scnt].r = i;
                    s[scnt].c = j;
                    s[scnt].stair = map[i][j];//계단 소요시간 저장
                    scnt++;
                }
            }
        }
        dfs(0, 0);
        printf("#%d %d\n", test_case, result);
    }
}


//실수목록...
//계단 용량을 >=3으로해서 싸이즈 4까지 가능하게 했다...ㅡㅡ
//용량이 다찼을때 계단 내려가는 부분을 잘 처리하지 못해서 여태 오류...
//이런 시간 계산하는거에 너무 약한 거같다.
//계단에 대기타고있는사람은 바로보내줘야하므로 -1해서 시작
~~~

개인적으로 모의고사 중 top3안에 드는 문제인 것 같다..  

후.. 시간은 이미 3시간을 지난지오래고 계속 도전해서 겨우 풀었다..  

시간계산하는게 너무 어려웠다.  

계단에 들어가서 1분 뒤 내려가는 것까지는 괜찮았는데  

이후에 계단이 3명이 꽉 차서 대기하는 사람이 있을 때,  

어떤 사람이 계단 내려가기를 완료한 시점에서 바로 대기탄 사람이 내려가야하는데  

1분뒤에 내려가는 부분을 잘 처리하지 못해서 시간을 잡아먹은 것 같다.  

이걸 그냥 체크할 수 없어서 프린트로 출력시키고 주어진 예제와 계속 비교하고....  

진짜 이런 문제 시험에 나오면..... 맨붕......  
